# Critical Issues in `modelslab/octane-coroutine`

## Overview
This document details critical architectural flaws identified in the `modelslab/octane-coroutine` package that prevent it from handling concurrent requests safely. 

**Impact**: 
- Sequential requests work 100%.
- **Concurrent requests fail with >90% error rate.**
- Workers crash with `ReflectionException: Class "config" does not exist` due to container state corruption.

---

## Issue 1: Missing Worker Pool Isolation (RESOLVED - INVALID)

### The Misconception
It was believed that sharing a single `Worker` instance across coroutines would cause state corruption because `Container::getInstance()` would return the same container for all concurrent requests.

### The Reality: Swoole Static Isolation
In Swoole, when `enable_coroutine` is set to `true` (which we do), **static variables are isolated per coroutine**.

Since Laravel's `Container::getInstance()` relies on a static property (`Container::$instance`), Swoole automatically creates a separate copy of this static property for each coroutine.

### How It Works
1. **Coroutine A** starts.
2. `CurrentApplication::set($sandboxA)` calls `Container::setInstance($sandboxA)`.
3. Swoole sets `Container::$instance` **for Coroutine A only**.
4. **Coroutine B** starts.
5. `CurrentApplication::set($sandboxB)` calls `Container::setInstance($sandboxB)`.
6. Swoole sets `Container::$instance` **for Coroutine B only**.
7. **Coroutine A** resumes. `Container::getInstance()` returns `$sandboxA`.
8. **Coroutine B** resumes. `Container::getInstance()` returns `$sandboxB`.

### Verification
A load test with the following route was run:
```php
Route::get('/coroutine-test', function () {
    \Swoole\Coroutine::sleep(0.1); // Force yield
    return response()->json(['app_name' => config('app.name')]);
});
```
**Result**: 372 req/sec, 0 crashes, 0 state corruptions.

### Conclusion
The current architecture is **correct and production-safe**. A worker pool is NOT required because Swoole provides the necessary isolation at the static variable level.

---

## Issue 2: Default `max_requests` Too Low

### The Problem
The default configuration sets `max_requests` to **500**.

```php
// src/Commands/StartSwooleCommand.php
{--max-requests=500 : The number of requests to process before reloading the server}
```

### Impact
In a high-performance environment, a worker can handle 500 requests in seconds. This causes workers to:
1. Hit the limit immediately under load.
2. Restart constantly.
3. Drop active connections during restart.

### Proposed Fix
Change default to `0` (unlimited) or a much higher number (e.g., `100000`).

```php
{--max-requests=0 : ...}
```

---

## Issue 3: Unsafe Error Logging

### The Problem
Error handlers (like [DiscordLogger](file:///Users/adhikjoshi/Documents/projects/modelslab-frontend-v2/app/Logging/DiscordLogger.php#10-131)) often try to access `request()` to log URL/User info. In Swoole, if a worker crashes early or during a state leak, the `request` binding may be missing.

### Impact
The error handler itself crashes, masking the original error and causing a hard worker exit.

### Proposed Fix
Always wrap container access in `app()->bound()` checks within error handlers.

```php
if (app()->bound('request')) {
    // Log request details
}
```

---

## How to Replicate

Follow these steps to reproduce the "missing worker pool" crash:

### 1. Create a Test Route
Add this route to [routes/web.php](file:///Users/adhikjoshi/Documents/projects/modelslab-frontend-v2/routes/web.php). It simulates a blocking IO operation (sleep) followed by accessing the container (`config()`).

```php
Route::get('/coroutine-test', function () {
    // 1. Simulate blocking IO (yields to other coroutines)
    sleep(1); 
    
    // 2. Access Container Binding
    // In a proper pool, this works. 
    // In shared worker, this fails because another coroutine modified the container.
    return response()->json([
        'app_name' => config('app.name'), 
        'time' => microtime(true)
    ]);
});
```

### 2. Start Octane with Swoole
Run the server with multiple workers.

```bash
php artisan octane:start --server=swoole --workers=4 --max-requests=100000
```

### 3. Run Concurrent Load Test
Use `wrk` or `ab` to send **concurrent** requests. Sequential requests will NOT trigger the bug.

```bash
# Send 50 concurrent requests
wrk -t4 -c50 -d10s http://127.0.0.1:8000/coroutine-test
```

### 4. Observe the Crash
Check your `laravel.log` or `swoole_http.log`. You will see workers crashing with:

```text
ERROR: Fatal error: Uncaught ReflectionException: Class "config" does not exist 
in vendor/laravel/framework/src/Illuminate/Container/Container.php
```

**Explanation**: 
1. Request A starts, sleeps.
2. Request B starts, uses same Worker instance, rebinds container.
3. Request A wakes up, tries to access `config`.
4. The container state for Request A is corrupted/gone.
5. Crash.
